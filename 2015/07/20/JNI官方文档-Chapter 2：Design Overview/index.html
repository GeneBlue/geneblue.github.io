<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="Personal Blog" />



  <meta name="keywords" content="Java JNI," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> JNI官方文档-Chapter 2：Design Overview // GeneBlue's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">GeneBlue's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              JNI官方文档-Chapter 2：Design Overview
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-20
        </span>

        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <p><strong>Author: GeneBlue</strong></p>
<p>本篇主要关注JNI设计中的主要问题。这里讲述的大多数问题都与本地方法有关。Invocation API的介绍在Chapter 5中。</p>
<h3 id="JNI-Interface-Functions-and-Pointers"><a href="#JNI-Interface-Functions-and-Pointers" class="headerlink" title="JNI Interface Functions and Pointers"></a>JNI Interface Functions and Pointers</h3><p>本地代码通过JNI函数可以获取JVM的一些特性。JNI函数可以通过一个接口指针获取。该接口指针是一个双重指针（指向指针的指针）。指针指向了一个指针数组，指针数组中的每一个成员都指向一个接口函数。每一个接口函数都在数组中预定义了一个偏移地址。下图可以表明接口指针的组织关系。</p>
<a id="more"></a>
<div align="center"><br><img src="http://7vzu7u.com1.z0.glb.clouddn.com/JNI-chapter%202-2-1.png " alt="JNI接口指针" title="JNI接口指针"><br></div>


<p>JNI接口是以类似于C++虚函数表或者COM接口的形式组织的。比起电路函数入口的方式，接口表的有点在于JNI的命名空间可以与本地代码分离开来。VM也可以较容易地提供多个版本的JNI函数表。例如，VM可以同时支持两种JNI函数表：</p>
<ul>
<li>一种可以执行严格的非法参数检查并且适合调试</li>
<li>另一种执行JNI规范文档中最低层次的参数检查，从而提高效率</li>
</ul>
<p>JNI接口指针在执行线程中保持不变。因此，本地方法不可以从一个线程传递接口指针到另一个线程。VM在实现JNI时应该分配并存储被JNI接口指针指向的线程数据。</p>
<p>本地方法以参数形式获取JNI接口指针。当从同一个java线程中多次调用本地方法时，VM可以确保传递相同的接口指针到本地方法。但是，一个本地方法可以被多个不同的java线程调用，因此也就能获得不同的JNI接口指针。</p>
<h3 id="Loading-and-Linking-Native-Methods"><a href="#Loading-and-Linking-Native-Methods" class="headerlink" title="Loading and Linking Native Methods"></a>Loading and Linking Native Methods</h3><p>本地方法由System.loadLibrary方法加载。以下代码示例中，在类初始化过程中加载了一个本地库并定义了库中实现的方法f。</p>
<pre><code>package pkg;
class Cls {
    native double f(int i, String s);
    static {
      System.loadLibrary(“pkg_Cls”);
    }
}
</code></pre><p>System.loadLibrary方法的参数是由开发者定义的库名。VM会遵循平台约定将库名转换为本地库名。如Solaris系统会将pkg_Cls库名转换为libpkg_Cls.so本地库名，Win32系统会将pkg_Cls转换成pkg_Cls.dll本地库名。</p>
<p>只要所有的java类由同一个classLoader对象加载，开发者就可以使用一个单独的库来存储所有的需要的本地方法。VM内部会为每一个classLoader维护一个本地库列表。VM构建者应该规范本地库的命名以减少名字冲突的几率。</p>
<p>如果一个OS不支持动态链接，那么所有的本地方法都必须与VM重新链接。在这种情况下，VM会完成System.loadLibrary方法的调用但并不会真的加载本地库。</p>
<p>开发人员也可以调用JNI的RegisterNatives()函数来注册于一个类相关联的本地方法。RegisterNatives()函数在静态链接中相当有用。</p>
<h3 id="Resolving-Native-Method-Names"><a href="#Resolving-Native-Method-Names" class="headerlink" title="Resolving Native Method Names"></a>Resolving Native Method Names</h3><p>动态连接器根据本地方法名来决定入口地址。一个本地方法名由以下几个部分连结而成：</p>
<ul>
<li>前缀 Java_</li>
<li>以下划线”_”分割开来的类名</li>
<li>带有下划线”_”的方法名</li>
<li>对于被加载的本地方法，两个下划线紧随参数签名</li>
</ul>
<p>VM会检查一个方法名是否匹配本地库中的方法名。VM首先检查短名，也就是没有参数签名的名字。随后检查带有参数签名的长名。当一个本地方法被另一个本地方法调用时，开发人员人员需要使用长名。但是，本地方法如果与非本地方法（java方法）有一样的名字也是也可接受的，因为非本地方法并不存在于本地库中。</p>
<p>在接下来的示例中，本地方法g没有使用长名，因为另一个方法g是非本地方法不属于本地库。</p>
<pre><code>class Cls1 {
    int g(int i);
    native int g(double d);
}
</code></pre><p>我们采用的简单命名方式可以确保所有的Unicode字符翻译为标准的C函数名。在完整的类名中，我们使用下划线”_”代替了斜线”/“。因为名字和类型描述符从不以数字开始，我们就是用_0,……,_9来表示转义字符。如表2-1所述：</p>
<p>表2-1：Unicode转义字符</p>
<table><br><tbody><br><br><tr><td><em>转义字符</em></td><td><em>注释</em></td></tr><br><tr><td>_0XXXX</td><td>一个Unicode字符XXXX。注意小写字母被用于表示非ASCII的Unicode字符，如：_0abcd与_0ABCD是相反的。</td></tr><br><tr><td><em>1</em></td><td>字符”“</td></tr><br><tr><td>_2</td><td>字符”;”</td></tr><br><tr><td>_3</td><td>字符”[“</td></tr><br><br></tbody><br></table>

<p>所有的本地方法和接口API都遵循平台的标准库调用规范。如，UNIX系统使用C调用规范，然而Win32系统使用_stdcall。</p>
<h3 id="Native-Method-Arguments"><a href="#Native-Method-Arguments" class="headerlink" title="Native Method Arguments"></a>Native Method Arguments</h3><p>JNI接口指针是第一个进入本地方法的参数。JNI接口指针是JNIEnv类型的。第二个参数依据本地方法是静态还是非静态而不同。非静态本地方法的第二个参数一般是一个对象的引用。静态方法的第二个参数是所属java类的引用。</p>
<p>余下的参数符合java方法的参数规律。本地方法调用使用返回值来传递结果给调用程序。Chapter 3中将描述java与C的类型关系。</p>
<p>代码示例2-1表明了使用 C 函数来实现本地方法f。本地方法f以如下形式声明：</p>
<pre><code>package pkg;
class Cls {
    native double f(int i, String s);
    ...
}
</code></pre><p>C函数以长命名方式Java_pkg_Cls_f_Iljava_lang_String_2的形式来实现本地方法f：</p>
<p>代码示例2-1以C代码形式实现了本地方法</p>
<pre><code>jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (
    JNIEnv *env, /* interface pointer */
    jobject obj, /* &quot;this&quot; pointer */
    jint i, /* argument #1 */
    jstring s) /* argument #2 */
{
    /* Obtain a Ccopy of the Java string */
    const char *str = (*env)-&gt;GetStringUTFChars(env, s, 0);
    /* process the string */
    ...
    /* Now we are done with str */
    (*env)-&gt;ReleaseStringUTFChars(env, s, str);
    return ...
}
</code></pre><p>注意，我们总是使用接口指针env来操纵java对象。使用C++，可以实现结构更加清晰的一个版本，如代码示例2-2所示：</p>
<pre><code>extern &quot;C&quot; /* specify the C calling convention */
jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (
    JNIEnv *env, /* interface pointer */
    jobject obj, /* &quot;this&quot; pointer */
    jint i, /* argument #1 */
    jstring s) /* argument #2 */
{
    const char *str = env-&gt;GetStringUTFChars(s, 0);
    ...
    env-&gt;ReleaseStringUTFChars(s, str);
    return ...
}
</code></pre><p>使用C++,可以做到从源码中消除其他等级的间接表达和接口指针参数。但是，其本质仍与C相同。在C++中，JNI函数以C为蓝本的内联函数的形式定义。</p>
<h3 id="Referencing-Java-Objects"><a href="#Referencing-Java-Objects" class="headerlink" title="Referencing Java Objects"></a>Referencing Java Objects</h3><p>原始的数据类型如intergers，characters等在java和本地代码中都会被拷贝。在任意一方的所有java对象都是通过引用来传递的。VM必须能够追踪所有被传递到本地代码中的java对象，因此这些java对象并不是由垃圾收集器清理释放的。于是，本地代码必须有一种方法通知VM不在需要某些java对象。此外，垃圾收集器也必须能够清理有本地代码所引用的java对象。</p>
<h3 id="Global-and-Local-References"><a href="#Global-and-Local-References" class="headerlink" title="Global and Local References"></a>Global and Local References</h3><p>JNI将引用对象划分成两类：局部和全局引用。局部引用在本地方法调用期间是可信的，并且在本地方法返回时自动被清理。全局引用在本地代码中一直存在，直至有了明确的清理要求。</p>
<p>对象以局部引用的形式传递到本地方法中。所有本JNI函数返回的java对象都是局部引用形式。JNI允许开发是将局部引用转变为全局引用。JNI函数允许java对象是局部引用和全局引用。本地方法可以以局部引用或全局引用的形式对VM返回结果。</p>
<p>在大多数情况下，开发人员应该依赖VM来清理所有的局部引用。但是，有几个特殊情况需要开发人员明确地清理局部引用。如下面情形：</p>
<ul>
<li>本地方法在获取一个很大的java对象后会创建该对象的局部引用。如果该本地方法在返回结果给调用者前要执行额外的计算任务。被创建的局部引用就会阻值对象被垃圾收集器清理，即使对象在计算过程中从未被使用。</li>
<li>当本地方法创建了大量的局部引用后。只要VM需要使用内存空间来追踪局部引用，创建太多的局部引用会引起返回值内存溢出。例如，本地方法循环遍历较大的对象数组，以引用方式检索数组成员并且以每个迭代器来操纵每个成员。之后，开发人员就不再需要局部引用来获取数组成员。</li>
</ul>
<p>JNI允许开发人员在本地方法的任意位置主动地清理局部引用。为了确保开发人员可以清理局部引用，JNI函数不会再创建额外的局部引用，处理作为返回值的引用。</p>
<p>局部引用只会存在本地方法所在的线程中。本地代码不可以将一个引用从一个线程传递到另一个线程。</p>
<h3 id="Implementing-Local-References"><a href="#Implementing-Local-References" class="headerlink" title="Implementing Local References"></a>Implementing Local References</h3><p>为了实现局部引用，JVM为每一个从java到native方法的过渡控制建立以注册表。每一个注册表都映射了局部映射到java对象并且一直保持到该对象被垃圾收集器回收。所有传递到native方法的java对象（包括那些作为JNI函数调用返回值的java对象）都自动地添加到注册表中。当native方法返回值后，注册表就会被删除并且所有的入口点都会被垃圾收集器回收。</p>
<p>有多种方式可以实现注册表，如使用table，linked list或者hash table。尽管为避免重复的入口点会在注册表中使用引用计数，但JNI的实现中并不总是检查并清理重复的入口点。</p>
<p>注意：局部引用不会忠实地通过扫描本地栈结构来实现。native代码也可能会将局部引用存储到全局或堆结构中。</p>
<h3 id="Accessing-Java-Objects"><a href="#Accessing-Java-Objects" class="headerlink" title="Accessing Java Objects"></a>Accessing Java Objects</h3><p>JNI在全局和局部引用中提供了一组丰富的读值函数（accessor functions）。这意味着同样的native方法实现在任何VM（不管VM内部是如何表达java对象的）中都是奏效的。这也是JNI可以被大量的VM支持的重要原因。</p>
<p>在非透明引用中使用读值函数的额外开销比直接使用C数据结构要高。我们相信，在大多数情况下，java开发者使用native方法来执行重要的任务比接口的额外开销要更实用。</p>
<h3 id="Accessing-Primitive-Arrays"><a href="#Accessing-Primitive-Arrays" class="headerlink" title="Accessing Primitive Arrays"></a>Accessing Primitive Arrays</h3><p>对于包含大量基本数据类型（如integer arrays和strings）的java对象这样的开销就不太适宜。考虑到native方法多用于执行vector和大量的计算。使用函数调用来获取java array，遍历array中的元素就会变得非常低效率。</p>
<p>有个方案提供了一种“阻塞”的概念让native方法可以要求VM来约束array中的内容。然后native方法就会获得一个指向array元素的指针。但是这种方法存在两个隐含的缺陷：</p>
<ul>
<li>垃圾收集器必须支持阻塞机制</li>
<li>VM必须将基本类型array连续地分配在内存中。尽管对于大多数基本类型array都是连续分配的，但boolean类型array是以封包或拆包的形式实现。因此，native代码对boolean类型array的处理就会复杂。</li>
</ul>
<p>我们采取了折中的方式来克服以上问题。</p>
<p>首先，我们提供了一组函数来拷贝java array段和native方法buffer中的每一个基本array元素。如果一个native方法需要在一个较大的array中访问一小部分的元素就可以使用这些函数。</p>
<p>其次，开发人员可以使用另一组函数来检索阻塞的array元素。记住这些函数可能会要求JVM执行内容分配和内容拷贝操作。不管这些函数拷贝数组的实现是否依赖于VM的实现，都会有以下两点：</p>
<ul>
<li>如果垃圾收集器支持阻塞，那么array的分配就如native方法期待的那样，也就不再需要内存拷贝。</li>
<li>另一方面，array被拷贝到不可移的内存块中（如C的堆）并且需要执行格式转换。指向该拷贝的指针会被返回。</li>
</ul>
<p>最后，接口提供的函数会通知VM native代码不再需要访问array元素。当调用这些函数时，系统并不会解除对array的阻塞，也不会协调原array与不可变拷贝和释放拷贝。</p>
<p>我们的方案提供了一种变通的方法。垃圾收集算法可以对每个给定的array做拷贝操作还是阻塞操作提供独立的决策。例如，垃圾收集器可以拷贝较小的对象，但会阻塞较大的对象。</p>
<p>JNI的实现必须要确保运行在多线程下的native方法能够同时获取相同的array。例如，JNI应该为每一个被阻塞的array都维持一个内部计数器，这样就可以做到一个线程能够解除对一个array的阻塞，但同时该array被另一个thread阻塞。注意：JNI不需要锁定只被一个native方法访问的基本类型array。同时从不同的线程更新java array对象会导致不确定的结果。</p>
<h3 id="Accessing-Fields-and-Methods"><a href="#Accessing-Fields-and-Methods" class="headerlink" title="Accessing Fields and Methods"></a>Accessing Fields and Methods</h3><p>JNI允许native代码访问field字段和调用java对象的方法。JNI通过名称和类型来识别方法和字段。一个两步式的进程会通过名称和类型来定位字段和方法，然后计算出开销。例如，为了调用cls类中的方法f，native代码首先以如下方式获取方法ID：</p>
<pre><code>jmethodID mid = env-&gt;GetMethodID(cls, “f”, “(ILjava/lang/String;)D”);
</code></pre><p>然后native代码会以如下形式反复地使用方法ID，不会再去查找方法：</p>
<pre><code>jdouble result = env-&gt;CallDoubleMethod(obj, mid, 10, str);
</code></pre><p>字段和方法ID不会阻止VM卸载ID已经被找到的类。当类被卸载掉后，方法或字段ID就会失效。因此，native代码必须确保：</p>
<ul>
<li>对装载过的类维持活动状态的引用，或</li>
<li>重新计算方法或字段ID</li>
</ul>
<p>如果在一段持续的时间里使用方法或字段ID。</p>
<p>JNI对字段和方法ID在内部是怎样实现的没有设置任何限制。</p>
<h3 id="Reporting-Programming-Errors"><a href="#Reporting-Programming-Errors" class="headerlink" title="Reporting Programming Errors"></a>Reporting Programming Errors</h3><p>JNI并不会检查编程错误如传递空指针或非法的参数类型。非法参数类型包括使用正常的java对象而不是java类对象。JNI不检查这些编程错误的原因在于：</p>
<ul>
<li>强制JNI函数检查所有的可能错误会降低正常native方法的效率。</li>
<li>在许多情况下，并没有足够的运行时类型信息来执行这样的检查。</li>
</ul>
<p>大多数的C函数库并未防止编程错误。例如，函数printf()在接收到一个非法地址时，通常会引起运行时（runtime）错误，而不会返回一个错误信息。强制C库函数对所有可能的错误情况都进行检查可能会导致：在用户代码中检查一遍后，还要在库代码中再检查一遍。</p>
<p>开发人员一定不可以给JNI函数传递非法指针或错误的参数类型。因为这样会导致不可预测的后果，包括中断系统状态或让VM崩溃。</p>
<h3 id="Java-Exceptions"><a href="#Java-Exceptions" class="headerlink" title="Java Exceptions"></a>Java Exceptions</h3><p>JNI允许native代码引起任意的java异常。native代码可能也会处理显著的java异常。剩下未处理的异常会被传播会VM。</p>
<h3 id="Exceptions-and-Error-Codes"><a href="#Exceptions-and-Error-Codes" class="headerlink" title="Exceptions and Error Codes"></a>Exceptions and Error Codes</h3><p>要明确JNI函数使用java异常来报告错误情况的机理。在大多数情况下，JNI函数会通过返回错误代码和抛出java异常来报告错误情况。错误代码通常是一些特殊的返回值（如NULL），这些返回值一般不在正常返回值之列。因此，开发人员应该做到：</p>
<ul>
<li>快速检查最后一个JNI函数调用后的返回值并判断是否有错误发生，并且</li>
<li>调用函数ExceptionOccurred()来获取异常对象，一般异常对象会包含更多的错误描述信息。</li>
</ul>
<p>有两个地方需要开发人员检查异常，这些异常并不会在第一次检查时返回错误代码：</p>
<ul>
<li>调用java方法的JNI函数返回java方法的结果。开发人员必须调用ExceptionOccured()函数来检查java方法在执行期间可能发生的异常。</li>
<li>一些获取array的JNI函数并不会返回错误代码，但是可能会抛出ArrayIndexOutOfBoundsException或ArrayStoreException异常。</li>
</ul>
<p>其它所有情况，一个non-error返回值可以保证没有异常被抛出。</p>
<h3 id="Asynchronous-Exceptions"><a href="#Asynchronous-Exceptions" class="headerlink" title="Asynchronous Exceptions"></a>Asynchronous Exceptions</h3><p>在多线程情况下，除了正在运行的线程，其余的线程可能会抛出一个异步异常。一个异步异常并不会在运行线程中立即影响native代码的执行，直到：</p>
<ul>
<li>native代码调用可能引起同步异常的JNI函数，或</li>
<li>native代码使用ExceptionOccurred()函数明确地检查同步和异步异常。</li>
</ul>
<p>注意：只有那些可能会潜在引起同步异常的JNI函数会检查异步异常。</p>
<p>native方法应该在必要的地方（如在一个没有其它异常检查的循环中）插入ExceptionOccurred()函数来确保当前线程在合理的时间内响应异步异常。</p>
<h3 id="Exception-Handling"><a href="#Exception-Handling" class="headerlink" title="Exception Handling"></a>Exception Handling</h3><p>有两种方式在native代码中处理异常：</p>
<ul>
<li>native方法可以选择立即返回，导致异常被抛出在java代码中，这些java代码一般启动native方法调用。</li>
<li>native代码通过调用ExceptionClear()函数来清除异常，然后执行它自己的异常处理代码。</li>
</ul>
<p>在异常发生后，native代码必须首先在引起其它JNI调用前清除异常。当存在一个挂起的异常，以下JNI函数是可以安全调用的：</p>
<pre><code>ExceptionOccurred()
ExceptionDescribe()
ExceptionClear()
ExceptionCheck()
ReleaseStringChars()
ReleaseStringUTFChars()
ReleaseStringCritical()
Release&lt;Type&gt;ArrayElements()
ReleasePrimitiveArrayCritical()
DeleteLocalRef()
DeleteGlobalRef()
DeleteWeakGlobalRef()
MonitorExit()
PushLocalFrame()
PopLocalFrame()
</code></pre>
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java-JNI/"> #Java JNI </a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/07/18/JNI官方文档-Chapter 1：Introduction/">JNI官方文档-Chapter 1：Introduction</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/07/21/JNI官方文档-Chapter 3：JNI Types and Data Structures/">JNI官方文档-Chapter 3：JNI Types and Data Structures</a>
            
          </div>
        </div>
      

      
      
    </div>
  </div>



    
      <div class="comments" id="comments">
        
      </div>
    
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="GeneBlue" />
          <p class="site-author-name">GeneBlue</p>
        </div>
        <p class="site-description motion-element">Personal Blog</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

      </div>

      
        <div class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#JNI-Interface-Functions-and-Pointers"><span class="nav-number">1.</span> <span class="nav-text">JNI Interface Functions and Pointers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Loading-and-Linking-Native-Methods"><span class="nav-number">2.</span> <span class="nav-text">Loading and Linking Native Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resolving-Native-Method-Names"><span class="nav-number">3.</span> <span class="nav-text">Resolving Native Method Names</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Native-Method-Arguments"><span class="nav-number">4.</span> <span class="nav-text">Native Method Arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Referencing-Java-Objects"><span class="nav-number">5.</span> <span class="nav-text">Referencing Java Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Global-and-Local-References"><span class="nav-number">6.</span> <span class="nav-text">Global and Local References</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-Local-References"><span class="nav-number">7.</span> <span class="nav-text">Implementing Local References</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-Java-Objects"><span class="nav-number">8.</span> <span class="nav-text">Accessing Java Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-Primitive-Arrays"><span class="nav-number">9.</span> <span class="nav-text">Accessing Primitive Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-Fields-and-Methods"><span class="nav-number">10.</span> <span class="nav-text">Accessing Fields and Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reporting-Programming-Errors"><span class="nav-number">11.</span> <span class="nav-text">Reporting Programming Errors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Exceptions"><span class="nav-number">12.</span> <span class="nav-text">Java Exceptions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exceptions-and-Error-Codes"><span class="nav-number">13.</span> <span class="nav-text">Exceptions and Error Codes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Asynchronous-Exceptions"><span class="nav-number">14.</span> <span class="nav-text">Asynchronous Exceptions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception-Handling"><span class="nav-number">15.</span> <span class="nav-text">Exception Handling</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </div>
      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2017
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">GeneBlue</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  
  

  




  
  

</body>
</html>
